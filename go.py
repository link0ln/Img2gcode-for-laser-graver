#!/usr/bin/env python3

import argparse
import logging
import sys
import os

import numpy as np
from PIL import Image

import cv2

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
)

def parse_args():
    parser = argparse.ArgumentParser(description="Image to G-code for laser engraver (offset/spiral fill).")
    parser.add_argument("image", help="Path to the input image file")
    parser.add_argument("--laser_resolution", type=float, default=0.07, help="Laser spot size in mm (default: 0.07)")
    parser.add_argument("--laser_power", type=int, default=255, help="Laser power (0=max, 255=min, default: 255)")
    parser.add_argument("--work_speed", type=int, default=1200, help="Working speed, F for engraving (default: 1200)")
    parser.add_argument("--travel_speed", type=int, default=3000, help="Travel speed, F for moves without laser (default: 3000)")
    parser.add_argument("--focus_height", type=float, default=5.0, help="Focus height in mm (default: 5.0)")
    parser.add_argument("--default_dpi", type=int, default=300, help="Default DPI if not found in image (default: 300)")
    return parser.parse_args()

def get_image_dpi(img, default_dpi):
    info = img.info
    dpi = None
    if "dpi" in info:
        dpi = info["dpi"][0]
    elif "resolution" in info:  # for some PNGs
        dpi = int(info["resolution"])
    else:
        dpi = default_dpi
    logging.info(f"Using DPI: {dpi}")
    return dpi

def image_to_binary_mask(img, white_threshold=240):
    logging.info("Converting image to binary mask...")
    img = img.convert("RGBA")
    arr = np.array(img)
    alpha = arr[:, :, 3]
    mask = (
        ((arr[:, :, 0] <= white_threshold) |
         (arr[:, :, 1] <= white_threshold) |
         (arr[:, :, 2] <= white_threshold)) &
        (alpha > 0)
    )
    mask = mask.astype(np.uint8)
    logging.info(f"Binary mask generated. Engraving area pixels: {np.sum(mask)}")
    return mask

def mask_to_offset_contours(mask, laser_width_px):
    """
    Делает offset fill (спиральная заливка) бинарной маски.
    mask - бинарная маска (uint8, 0 или 1)
    laser_width_px - ширина лазера в пикселях (>=1)
    Возвращает список контуров, где каждый — последовательность (x, y) точек
    """
    logging.info(f"Offset fill: laser width = {laser_width_px} px")
    contours_list = []
    cur_mask = (mask * 255).astype(np.uint8)
    kernel = np.ones((laser_width_px, laser_width_px), np.uint8)
    iteration = 0

    while np.any(cur_mask):
        # Ищем только внешние контуры (RETR_EXTERNAL)
        contours, _ = cv2.findContours(cur_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        if not contours:
            break
        for cnt in contours:
            # cnt: (N,1,2) -> нужно преобразовать в [(x, y), ...]
            path = [(int(pt[0][0]), int(pt[0][1])) for pt in cnt]
            if len(path) > 2:
                contours_list.append(path)
        cur_mask = cv2.erode(cur_mask, kernel, iterations=1)
        iteration += 1
    logging.info(f"Total offset contours: {len(contours_list)}")
    return contours_list

def pixel_to_mm(x, y, img_w, img_h, physical_w, physical_h, center_origin=True):
    """Преобразует координаты пикселя в мм с центровкой"""
    if center_origin:
        x_mm = (x - img_w / 2) * (physical_w / img_w)
        y_mm = (y - img_h / 2) * (physical_h / img_h)
    else:
        x_mm = x * (physical_w / img_w)
        y_mm = y * (physical_h / img_h)
    return x_mm, y_mm

def generate_gcode(
    contours, img_w, img_h, physical_w, physical_h, 
    laser_resolution, laser_power, work_speed, travel_speed, focus_height, center_origin, filename
):
    logging.info("Generating G-code (offset/spiral fill)...")
    gcode = []

    gcode.append(f"; Generated by image2gcode (offset fill)")
    gcode.append(f"G21 ; set units to mm")
    gcode.append(f"G90 ; absolute positioning")
    gcode.append(f"G1 Z{focus_height:.3f} F{travel_speed} ; move laser head to focus height")
    gcode.append(f"M106 P0 S255 ; laser OFF")
    gcode.append("G4 S3 ; wait 3 seconds before start")

    last_position = None
    contour_num = 0

    for path in contours:
        contour_num += 1
        if not path:
            continue
        start_x, start_y = path[0]
        start_x_mm, start_y_mm = pixel_to_mm(
            start_x, start_y, img_w, img_h, physical_w, physical_h, center_origin=center_origin)
        # Если мы не в начале, то делаем холостой ход к старту нового контура
        if last_position is None or (abs(last_position[0]-start_x_mm) > 1e-4 or abs(last_position[1]-start_y_mm) > 1e-4):
            gcode.append(f"M106 P0 S255 ; laser OFF")
            gcode.append(
                f"G1 X{start_x_mm:.3f} Y{start_y_mm:.3f} F{travel_speed} ; travel to start of contour #{contour_num}")

        gcode.append(f"M106 P0 S{laser_power} ; laser ON")
        # Движение вдоль контура
        for px, py in path:
            x_mm, y_mm = pixel_to_mm(
                px, py, img_w, img_h, physical_w, physical_h, center_origin=center_origin)
            gcode.append(
                f"G1 X{x_mm:.3f} Y{y_mm:.3f} F{work_speed} ; contour #{contour_num}")
        gcode.append(f"M106 P0 S255 ; laser OFF")
        last_position = (x_mm, y_mm)

    gcode.append("M106 P0 S255 ; laser OFF (final)")
    logging.info("G-code generation finished.")
    # Сохраняем
    with open(filename, "w") as f:
        for line in gcode:
            f.write(line + "\n")
    logging.info(f"G-code saved to {filename}")

def main():
    args = parse_args()
    image_path = args.image
    output_gcode = image_path + ".gcode"

    # 1. Загрузка изображения
    logging.info(f"Opening image: {image_path}")
    img = Image.open(image_path)
    dpi = get_image_dpi(img, args.default_dpi)
    img_w, img_h = img.size
    physical_w = img_w / dpi * 25.4
    physical_h = img_h / dpi * 25.4
    logging.info(f"Image size: {img_w}x{img_h} px, physical size: {physical_w:.2f}x{physical_h:.2f} mm")

    # 2. Бинаризация
    mask = image_to_binary_mask(img, white_threshold=240)

    # 3. Ширина лазера в пикселях
    laser_width_px = max(1, int(np.ceil(args.laser_resolution / (25.4 / dpi))))
    logging.info(f"Laser width: {args.laser_resolution} mm = {laser_width_px} px at {dpi} DPI")

    # 4. Offset fill по всей области (маске)
    contours = mask_to_offset_contours(mask, laser_width_px)

    # 5. Генерация G-code
    generate_gcode(
        contours, img_w, img_h, physical_w, physical_h,
        args.laser_resolution, args.laser_power, args.work_speed, args.travel_speed,
        args.focus_height, True, output_gcode
    )

if __name__ == "__main__":
    main()
